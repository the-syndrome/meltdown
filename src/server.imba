import "dotenv/config"
import { createServer } from "http"
import isNil from "lodash/isNil"
import isEmpty from "lodash/isEmpty"
import isFunction from "lodash/isFunction"
import isArray from "lodash/isArray"
import isBoolean from "lodash/isBoolean"
import isNumber from "lodash/isNumber"
import isString from "lodash/isString"
import isObject from "lodash/isObject"
import get from "lodash/get"
import find from "lodash/find"
import omit from "lodash/omit"
import uniq from "lodash/uniq"
import compact from "lodash/compact"
import restana from "restana"
import posthtml from "posthtml"
import htmlnano from "htmlnano"
import index from "./index.html"
import { SiteClient } from "./client"
import routes from "../.tmp/routes"
import { toBinary } from "./lib/encoding"
import articles from "../data/articles.json"
import textblocks from "../data/textblocks.json"

def errorHandler err, req, res
	const { message, stack, status } = err
	console.error "error rendering page", status, message, stack
	res.send "server error 500", 500, { "content-type": "text/plain" }

const { NODE_ENV, PORT } = process.env
const router = restana { errorHandler }
const server = createServer router
const port = PORT or 3000
const contentTypeHtml = { "content-type": "text/html" }
const jsonMime = "application/json"
const contentTypeJson = { "content-type": jsonMime }
const isPrd = NODE_ENV is "production"

# use the HTML generated by esbuild but customize it
def createPagePlugin { recis1, recis2, title, page }
	def pagePlugin tree
		tree.match { tag: "title" }, do(node)
			const t = unescape(title)
			if isNil(node.content)
				node.content = t
			else
				node.content.unshift `{t} - `
			node
		tree.match { tag: "body" }, do(node)
			if isNil(node.attrs) then node.attrs = {}
			node.content.push { tag: 'template', attrs: { id: "iNEmQL" }, content: recis1 }
			node.content.push { tag: 'template', attrs: { id: "JW29a4" }, content: recis2 }
			node.content.unshift tree.parser(page)
			node

router.use do(req, res, next)
	res.locals = {}
	next!

# mock articles API that pulls from ../data
router.get "/articles", do(req, res, next)
	const { query } = req
	const accept = get req, "headers.accept", ""
	if accept.includes jsonMime
		let op
		if isEmpty(query)
			op = articles
				.filter(do(item) item.pathname.startsWith("/posts"))
				.map(do(item) omit(item, ["body"]))
		else
			op = find(articles,  query)
		return res.send op, 200, contentTypeJson
	next!

# mock textblocks API
router.get "/textblocks", do(req, res, next)
	const accept = get req, "headers.accept", ""
	if accept.includes jsonMime
		return res.send textblocks, 200, contentTypeJson
	next!

# articles from dynamic content
for article in articles
	router.get article.pathname, do(req, res, next)
		console.log "before load article"
		const mod = await import("./pages/posts/[slug].imba")
		console.log "after load article"
		res.screen = mod.default
		res.locals.article = article
		next!

# routes constructed from ./pages
for { pattern, load } in routes
	router.get pattern, do(req, res, next)
		const { default: screen } = await load!
		res.screen = screen
		if isFunction(screen.GET)
			return screen.GET(req, res, next)
		next!

export def renderPage { screen, query, params, locals }
	# convert these context variables into binary
	let initialState = {}
	if not isEmpty(query) then initialState.query = query
	if not isEmpty(params) then initialState.params = params
	if not isEmpty(locals) then initialState.locals = locals
	initialState = JSON.stringify initialState
	const recis = toBinary initialState
	const half = recis.length > 10 ? Math.floor(recis.length / 2) : recis.length
	const recis1 = recis.substring(0, half)
	const recis2 = recis.substring(half).split("").reverse().join("")
	# render to html
	let page = <SiteClient screen=screen query=query params=params locals=locals>
	page = String page
	const title = get(locals, "title") or get(screen, "title") or ""
	html = posthtml!.use(createPagePlugin({ recis1, recis2, title, page }))
	# if isPrd then html = html.use(htmlnano)
	html = html.process(index.body, { sync: true }).html
	html

router.get "*" do(req, res)
	console.log req.method, req.url
	const { screen, locals } = res
	const { query, params } = req
	console.log "before render"
	const html = renderPage { screen, locals, query, params }
	console.log "after render"
	res.send html, 200, contentTypeHtml

imba.serve server.listen(port)
