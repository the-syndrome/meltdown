import "dotenv/config"
import { createServer } from "http"
import isNil from "lodash/isNil"
import isEmpty from "lodash/isEmpty"
import isFunction from "lodash/isFunction"
import isArray from "lodash/isArray"
import isBoolean from "lodash/isBoolean"
import isNumber from "lodash/isNumber"
import isString from "lodash/isString"
import isObject from "lodash/isObject"
import get from "lodash/get"
import find from "lodash/find"
import omit from "lodash/omit"
import uniq from "lodash/uniq"
import compact from "lodash/compact"
import restana from "restana"
import posthtml from "posthtml"
import index from "./index.html"
import { SiteClient } from "./client"
import routes from "../.tmp/routes"
import { toBinary } from "./lib/encoding"
import articles from "../data/articles.json"
import textblocks from "../data/textblocks.json"
import Error404 from "./pages/_Error404"
import Error500 from "./pages/_Error500"

const {
	PORT: port = 33765
	NODE_ENV = "development"
	MELTDOWN_STATE1 = "iNEmQL"
	MELTDOWN_STATE2 = "JW29a4"
} = process.env
const isPrd = NODE_ENV is "production"
const htmlMime = "text/html"
const jsonMime = "application/json"
const textMime = "text/plain"
const contentTypeHtml = { "content-type": htmlMime }
const contentTypeJson = { "content-type": jsonMime }
const contentTypeText = { "content-type": textMime }

def errorHandler err, req, res
	const { message, stack, status = 500 } = err
	console.error "error rendering page", status, message, stack
	if not res.headersSent
		const accept = get req, "headers.accept", ""
		let headers = {}
		let body = ""
		if accept.includes htmlMime
			const screen = Error500
			headers = contentTypeHtml
			body = renderPage { screen }
		elif accept.includes jsonMime
			headers = contentTypeJson
			body = { error: true }
			if not isPrd then body.message = message
		else
			headers = contentTypeText
			body = "server error {status}"
			if not isPrd then body = "{body}, {message}"
		res.send body, status, headers

const router = restana { errorHandler }
const server = createServer router

# use the HTML generated by esbuild but customize it
def createPagePlugin { state1, state2, title, page }
	def pagePlugin tree
		tree.match { tag: "title" }, do(node)
			const t = unescape(title)
			if isNil(node.content)
				node.content = t
			else
				node.content.unshift `{t} - `
			node
		tree.match { tag: "body" }, do(node)
			if isNil(node.attrs) then node.attrs = {}
			# add obfuscated state in two templates which the client deserializes
			node.content.push {
				tag: 'template'
				attrs: { id: MELTDOWN_STATE1 } # configured in .env
				content: state1
			}
			node.content.push {
				tag: 'template'
				attrs: { id: MELTDOWN_STATE2 } # configured in .env
				content: state2
			}
			node.content.unshift tree.parser(page)
			node

router.use do(req, res, next)
	res.locals = {}
	next!

# mock articles API that pulls from ../data
router.get "/articles", do(req, res, next)
	const { query } = req
	const accept = get req, "headers.accept", ""
	if accept.includes jsonMime
		let op
		if isEmpty(query)
			op = articles
				.filter(do(item) item.pathname.startsWith("/posts"))
				.map(do(item) omit(item, ["body"]))
		else
			op = find(articles,  query)
		return res.send op, 200, contentTypeJson
	next!

# mock textblocks API
router.get "/textblocks", do(req, res, next)
	const accept = get req, "headers.accept", ""
	if accept.includes jsonMime
		return res.send textblocks, 200, contentTypeJson
	next!

# articles from dynamic content
for article in articles
	router.get article.pathname, do(req, res, next)
		const mod = await import("./pages/posts/[slug].imba")
		res.screen = mod.default
		res.locals.article = article
		next!

# routes constructed from ./pages
for { pattern, load } in routes
	router.get pattern, do(req, res, next)
		const { default: screen } = await load!
		res.screen = screen
		next!

export def renderPage { screen, query = {}, params = {}, locals = {} }
	# convert these context variables into binary
	let initialState = {}
	if not isEmpty(query) then initialState.query = query
	if not isEmpty(params) then initialState.params = params
	if not isEmpty(locals) then initialState.locals = locals
	initialState = JSON.stringify initialState
	# split the state in two and obfuscate it thus preventing scraping
	const state = toBinary initialState
	const half = state.length > 10 ? Math.floor(state.length / 2) : state.length
	const state1 = state.substring(0, half)
	const state2 = state.substring(half).split("").reverse!.join("")
	# render to html
	let page = ""
	try
		page = <SiteClient screen=screen query=query params=params locals=locals>
	catch err
		const { message, stack } = err
		console.error "error rendering page", message, stack
	page = String page
	const title = locals.title or screen.title or ""
	let html = posthtml!.use(createPagePlugin({ state1, state2, title, page }))
	html = html.process(index.body, { sync: true }).html
	html

def loadFallback
	const mod = await import("./pages/posts/[slug].imba")
	mod.default

# some pages provide their own middleware
router.get "*", do(req, res, next)
	const { screen = (await loadFallback!) } = res
	if isFunction(screen.GET)
		screen.GET(req, res, next)
		return
	next!

# finally render it
router.get "*" do(req, res)
	let { screen = (await loadFallback!), locals, status = 200 } = res
	const { query, params } = req
	if res.status is 404
		screen = Error404
	elif res.status >= 500
		screen = Error500
	const html = renderPage { screen, locals, query, params }
	res.send html, status, contentTypeHtml

imba.serve server.listen(port)
